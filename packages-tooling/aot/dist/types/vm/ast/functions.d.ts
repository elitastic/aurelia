import { ArrowFunction, ConstructorDeclaration, FunctionDeclaration, FunctionExpression, ModifierFlags, ParameterDeclaration, SyntaxKind } from 'typescript';
import { ILogger } from '@aurelia/kernel';
import { Realm, ExecutionContext } from '../realm';
import { $EnvRec, $DeclarativeEnvRec, $FunctionEnvRec } from '../types/environment-record';
import { $String } from '../types/string';
import { $Undefined } from '../types/undefined';
import { $Function } from '../types/function';
import { $Any, $AnyNonEmpty, $PropertyKey } from '../types/_shared';
import { $Object } from '../types/object';
import { $Empty } from '../types/empty';
import { $IteratorRecord } from '../globals/iteration';
import { $Error } from '../types/error';
import { I$Node, Context, $$ESDeclaration, $NodeWithStatements, $$AssignmentExpressionOrHigher, $$TSDeclaration, $$BindingName, $AnyParentNode, $$ESVarDeclaration, FunctionKind } from './_shared';
import { ExportEntryRecord, $$ESModuleOrScript } from './modules';
import { $Identifier, $Decorator } from './expressions';
import { $ClassDeclaration, $ClassExpression } from './classes';
import { $Block, DirectivePrologue } from './statements';
import { $MethodDeclaration, $SetAccessorDeclaration, $GetAccessorDeclaration } from './methods';
import { $Boolean } from '../types/boolean';
import { $List } from '../types/list';
export type $$Function = ($FunctionDeclaration | $FunctionExpression | $MethodDeclaration | $ConstructorDeclaration | $SetAccessorDeclaration | $GetAccessorDeclaration | $ArrowFunction);
export declare class $FormalParameterList extends Array<$ParameterDeclaration> {
    readonly BoundNames: readonly $String[];
    readonly ContainsExpression: boolean;
    readonly ExpectedArgumentCount: number;
    readonly HasInitializer: boolean;
    readonly IsSimpleParameterList: boolean;
    readonly hasDuplicates: boolean;
    constructor(nodes: readonly ParameterDeclaration[] | undefined, parent: $$Function, ctx: Context);
}
export declare class $FunctionExpression implements I$Node {
    readonly node: FunctionExpression;
    readonly parent: $AnyParentNode;
    readonly ctx: Context;
    readonly idx: number;
    readonly mos: $$ESModuleOrScript;
    readonly realm: Realm;
    readonly depth: number;
    readonly logger: ILogger;
    readonly path: string;
    get $kind(): SyntaxKind.FunctionExpression;
    readonly modifierFlags: ModifierFlags;
    readonly $name: $Identifier | undefined;
    readonly $parameters: $FormalParameterList;
    readonly $body: $Block;
    readonly BoundNames: readonly $String[];
    readonly ContainsUseStrict: boolean;
    readonly HasName: boolean;
    readonly IsConstantDeclaration: false;
    readonly IsFunctionDefinition: true;
    readonly LexicallyDeclaredNames: readonly $String[];
    readonly LexicallyScopedDeclarations: readonly $$ESDeclaration[];
    readonly VarDeclaredNames: readonly $String[];
    readonly VarScopedDeclarations: readonly $$ESVarDeclaration[];
    readonly DirectivePrologue: DirectivePrologue;
    readonly TypeDeclarations: readonly $$TSDeclaration[];
    readonly IsType: false;
    readonly functionKind: FunctionKind.normal | FunctionKind.generator | FunctionKind.async | FunctionKind.asyncGenerator;
    constructor(node: FunctionExpression, parent: $AnyParentNode, ctx: Context, idx: number, mos?: $$ESModuleOrScript, realm?: Realm, depth?: number, logger?: ILogger, path?: string);
    EvaluateBody(ctx: ExecutionContext<$FunctionEnvRec, $FunctionEnvRec>, functionObject: $Function, argumentsList: $List<$AnyNonEmpty>): $Any;
    Evaluate(ctx: ExecutionContext): $Function | $Error;
    private $Evaluate;
    private $EvaluateGenerator;
    private $EvaluateAsyncGenerator;
    private $EvaluateAsync;
    EvaluateNamed(ctx: ExecutionContext, name: $String): $Function | $Error;
}
export declare class $FunctionDeclaration implements I$Node {
    readonly node: FunctionDeclaration;
    readonly parent: $NodeWithStatements;
    readonly ctx: Context;
    readonly idx: number;
    readonly mos: $$ESModuleOrScript;
    readonly realm: Realm;
    readonly depth: number;
    readonly logger: ILogger;
    readonly path: string;
    get $kind(): SyntaxKind.FunctionDeclaration;
    readonly modifierFlags: ModifierFlags;
    readonly $decorators: readonly $Decorator[];
    readonly $name: $Identifier | undefined;
    readonly $parameters: $FormalParameterList;
    readonly $body: $Block;
    readonly BoundNames: readonly [$String | $String<'*default*'>] | readonly $String[];
    readonly ContainsUseStrict: boolean;
    readonly HasName: boolean;
    readonly IsConstantDeclaration: false;
    readonly IsFunctionDefinition: true;
    readonly LexicallyDeclaredNames: readonly $String[];
    readonly LexicallyScopedDeclarations: readonly $$ESDeclaration[];
    readonly VarDeclaredNames: readonly $String[];
    readonly VarScopedDeclarations: readonly $$ESVarDeclaration[];
    readonly PropName: $String | $Undefined;
    readonly DirectivePrologue: DirectivePrologue;
    readonly ExportedBindings: readonly $String[];
    readonly ExportedNames: readonly $String[];
    readonly ExportEntries: readonly ExportEntryRecord[];
    readonly ModuleRequests: readonly $String[];
    readonly TypeDeclarations: readonly $$TSDeclaration[];
    readonly IsType: false;
    readonly functionKind: FunctionKind.normal | FunctionKind.generator | FunctionKind.async | FunctionKind.asyncGenerator;
    constructor(node: FunctionDeclaration, parent: $NodeWithStatements, ctx: Context, idx: number, mos?: $$ESModuleOrScript, realm?: Realm, depth?: number, logger?: ILogger, path?: string);
    InstantiateFunctionObject(ctx: ExecutionContext, Scope: $EnvRec): $Function | $Error;
    private $InstantiateFunctionObject;
    private $InstantiateGeneratorFunctionObject;
    private $InstantiateAsyncGeneratorFunctionObject;
    private $InstantiateAsyncFunctionObject;
    EvaluateBody(ctx: ExecutionContext<$FunctionEnvRec, $FunctionEnvRec>, functionObject: $Function, argumentsList: $List<$AnyNonEmpty>): $Any;
    Evaluate(ctx: ExecutionContext): $Empty;
}
export declare function $FunctionDeclarationInstantiation(ctx: ExecutionContext<$FunctionEnvRec | $DeclarativeEnvRec>, func: $Function, argumentsList: $List<$AnyNonEmpty>): $Empty | $Error;
export declare class $ArrowFunction implements I$Node {
    readonly node: ArrowFunction;
    readonly parent: $AnyParentNode;
    readonly ctx: Context;
    readonly idx: number;
    readonly mos: $$ESModuleOrScript;
    readonly realm: Realm;
    readonly depth: number;
    readonly logger: ILogger;
    readonly path: string;
    get $kind(): SyntaxKind.ArrowFunction;
    readonly modifierFlags: ModifierFlags;
    readonly $parameters: $FormalParameterList;
    readonly $body: $Block | $$AssignmentExpressionOrHigher;
    readonly BoundNames: readonly $String[];
    readonly ContainsUseStrict: boolean;
    readonly HasName: false;
    readonly CoveredFormalsList: $FormalParameterList;
    readonly LexicallyDeclaredNames: readonly $String[];
    readonly LexicallyScopedDeclarations: readonly $$ESDeclaration[];
    readonly VarDeclaredNames: readonly $String[];
    readonly VarScopedDeclarations: readonly $$ESVarDeclaration[];
    readonly DirectivePrologue: DirectivePrologue;
    readonly TypeDeclarations: readonly $$TSDeclaration[];
    readonly IsType: false;
    readonly functionKind: FunctionKind.normal | FunctionKind.async;
    constructor(node: ArrowFunction, parent: $AnyParentNode, ctx: Context, idx: number, mos?: $$ESModuleOrScript, realm?: Realm, depth?: number, logger?: ILogger, path?: string);
    Evaluate(ctx: ExecutionContext): $AnyNonEmpty;
    EvaluateBody(ctx: ExecutionContext<$FunctionEnvRec, $FunctionEnvRec>, functionObject: $Function, argumentsList: $List<$AnyNonEmpty>): $Any;
}
export declare class MethodDefinitionRecord {
    '[[Key]]': $PropertyKey;
    '[[Closure]]': $Function;
    get isAbrupt(): false;
    constructor(key: $PropertyKey, closure: $Function);
}
export declare class $ConstructorDeclaration implements I$Node {
    readonly node: ConstructorDeclaration;
    readonly parent: $ClassDeclaration | $ClassExpression;
    readonly ctx: Context;
    readonly idx: number;
    readonly mos: $$ESModuleOrScript;
    readonly realm: Realm;
    readonly depth: number;
    readonly logger: ILogger;
    readonly path: string;
    get $kind(): SyntaxKind.Constructor;
    readonly modifierFlags: ModifierFlags;
    readonly $decorators: readonly $Decorator[];
    readonly $parameters: $FormalParameterList;
    readonly $body: $Block;
    readonly LexicallyDeclaredNames: readonly $String[];
    readonly LexicallyScopedDeclarations: readonly $$ESDeclaration[];
    readonly VarDeclaredNames: readonly $String[];
    readonly VarScopedDeclarations: readonly $$ESVarDeclaration[];
    readonly functionKind: FunctionKind.normal;
    constructor(node: ConstructorDeclaration, parent: $ClassDeclaration | $ClassExpression, ctx: Context, idx: number, mos?: $$ESModuleOrScript, realm?: Realm, depth?: number, logger?: ILogger, path?: string);
    DefineMethod(ctx: ExecutionContext, object: $Object, functionPrototype: $Object): MethodDefinitionRecord;
    EvaluateBody(ctx: ExecutionContext<$FunctionEnvRec, $FunctionEnvRec>, functionObject: $Function, argumentsList: $List<$AnyNonEmpty>): $Any;
}
export declare class $ParameterDeclaration implements I$Node {
    readonly node: ParameterDeclaration;
    readonly parent: $$Function;
    readonly ctx: Context;
    readonly idx: number;
    readonly mos: $$ESModuleOrScript;
    readonly realm: Realm;
    readonly depth: number;
    readonly logger: ILogger;
    readonly path: string;
    get $kind(): SyntaxKind.Parameter;
    readonly modifierFlags: ModifierFlags;
    readonly combinedModifierFlags: ModifierFlags;
    readonly $decorators: readonly $Decorator[];
    readonly $name: $$BindingName;
    readonly $initializer: $$AssignmentExpressionOrHigher | undefined;
    readonly BoundNames: readonly $String[] | readonly [$String];
    readonly ContainsExpression: boolean;
    readonly HasInitializer: boolean;
    readonly IsSimpleParameterList: boolean;
    constructor(node: ParameterDeclaration, parent: $$Function, ctx: Context, idx: number, mos?: $$ESModuleOrScript, realm?: Realm, depth?: number, logger?: ILogger, path?: string);
    InitializeIteratorBinding(ctx: ExecutionContext, iteratorRecord: $IteratorRecord, environment: $EnvRec | undefined): $Object<string> | import("../..").$Null | $Empty | $Error<Error, string> | $Undefined | $Boolean<boolean> | $String<string> | import("../..").$Symbol<$String<string> | $Undefined> | import("../..").$Number<number> | undefined;
}
//# sourceMappingURL=functions.d.ts.map