import { HttpClient } from '../http-client';
import { IFetchInterceptor } from '../interfaces';
/**
 * The strategy to use when retrying requests.
 */
export declare const RetryStrategy: Readonly<{
    fixed: 0;
    incremental: 1;
    exponential: 2;
    random: 3;
}>;
/**
 * Interceptor that retries requests on error, based on a given RetryConfiguration.
 */
export declare class RetryInterceptor implements IFetchInterceptor {
    retryConfig: IRetryConfiguration;
    /**
     * Creates an instance of RetryInterceptor.
     */
    constructor(retryConfig?: IRetryConfiguration);
    /**
     * Called with the request before it is sent. It remembers the request so it can be retried on error.
     *
     * @param request - The request to be sent.
     * @returns The existing request, a new request or a response; or a Promise for any of these.
     */
    request(request: IRetryableRequest): IRetryableRequest;
    /**
     * Called with the response after it is received. Clears the remembered request, as it was succesfull.
     *
     * @param response - The response.
     * @returns The response; or a Promise for one.
     */
    response(response: Response, request: IRetryableRequest): Response;
    /**
     * Handles fetch errors and errors generated by previous interceptors. This
     * function acts as a Promise rejection handler. It wil retry the remembered request based on the
     * configured RetryConfiguration.
     *
     * @param error - The rejection value from the fetch request or from a
     * previous interceptor.
     * @returns The response of the retry; or a Promise for one.
     */
    responseError(error: Response, request: IRetryableRequest, httpClient: HttpClient): Response | Promise<Response>;
}
export type IRetryableRequest = Request & {
    retryConfig?: IRetryConfiguration;
};
export interface IRetryConfiguration {
    maxRetries: number;
    interval?: number;
    strategy?: number | ((retryCount: number) => number);
    minRandomInterval?: number;
    maxRandomInterval?: number;
    counter?: number;
    requestClone?: Request;
    doRetry?(response: Response, request: Request): boolean | Promise<boolean>;
    beforeRetry?(request: Request, client: HttpClient): Request | Promise<Request>;
}
//# sourceMappingURL=retry-interceptor.d.ts.map